using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Amethystra.CodeAnalysis;

[Generator(LanguageNames.CSharp)]
public sealed class GenerateLoggerGenerator : IIncrementalGenerator
{
    private const string _attributeMetadataName = "Amethystra.Diagnostics.GenerateLoggerAttribute";
    private const string _attributeSource =
        """
        // <auto-generated/>
        // This file was generated by Amethystra.CodeAnalysis.GenerateLoggerGenerator.
        // Do not edit this file manually.

        using System;

        namespace Amethystra.Diagnostics;

        [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, Inherited = false, AllowMultiple = false)]
        internal sealed class GenerateLoggerAttribute : Attribute;
        """;

    private static readonly DiagnosticDescriptor _typeMustBePartial = new(
        "AMLG001",
        "GenerateLogger requires partial type",
        "Type '{0}' must be declared 'partial' to use [GenerateLogger]",
        "Amethystra.GenerateLogger",
        DiagnosticSeverity.Error,
        true);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static ctx =>
        {
            ctx.AddSource(
                "GenerateLoggerAttribute.g.cs",
                SourceText.From(_attributeSource, Encoding.UTF8));
        });

        var targets = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                _attributeMetadataName,
                static (node, _) => node is TypeDeclarationSyntax,
                static (ctx, _) =>
                {
                    var symbol = (INamedTypeSymbol)ctx.TargetSymbol;
                    var syntax = (TypeDeclarationSyntax)ctx.TargetNode;
                    return new Target(symbol, syntax);
                });

        context.RegisterSourceOutput(
            targets,
            static (spc, target) =>
            {
                if (IsPartial(target.TypeSyntax) == false)
                {
                    spc.ReportDiagnostic(
                        Diagnostic.Create(
                            _typeMustBePartial,
                            target.TypeSyntax.Identifier.GetLocation(),
                            target.TypeSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)));

                    return;
                }

                var source = GeneratePartial(target.TypeSymbol);
                var hintName = CreateHintName(target.TypeSymbol);

                spc.AddSource(hintName, SourceText.From(source, Encoding.UTF8));
            });
    }

    private static bool IsPartial(TypeDeclarationSyntax syntax)
        => syntax.Modifiers.Any(static x => x.IsKind(SyntaxKind.PartialKeyword));

    private static string CreateHintName(INamedTypeSymbol type)
    {
        var name = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        name = name.Replace("global::", "");
        name = name.Replace('<', '[').Replace('>', ']');
        name = name.Replace(',', '_');
        name = name.Replace('.', '_');
        name = name.Replace('+', '_');
        name = name.Replace(':', '_');
        return $"{name}.Logger.g.cs";
    }

    private static string GeneratePartial(INamedTypeSymbol typeSymbol)
    {
        var ns = typeSymbol.ContainingNamespace.IsGlobalNamespace
            ? null
            : typeSymbol.ContainingNamespace.ToDisplayString();
        var fullyQualifiedType = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.Append("// This file was generated by ").Append(typeof(GenerateLoggerGenerator).FullName).AppendLine(".");
        sb.AppendLine("// Do not edit this file manually.");
        sb.AppendLine("// To regenerate, build the project (types marked with [Amethystra.Diagnostics.GenerateLogger]).");
        sb.Append("// Target type: ").Append(fullyQualifiedType).AppendLine();
        sb.AppendLine();

        if (string.IsNullOrWhiteSpace(ns) == false)
        {
            sb.Append("namespace ").Append(ns).AppendLine(";");
            sb.AppendLine();
        }

        foreach (var line in OpenContainingTypes(typeSymbol))
        {
            sb.AppendLine(line);
        }

        var indent = new string(' ', GetIndentLevel(typeSymbol) * 4);

        sb.Append(indent)
            .Append(GetStaticModifier(typeSymbol))
            .Append("partial ")
            .Append(GetTypeKeyword(typeSymbol))
            .Append(' ')
            .Append(typeSymbol.Name)
            .Append(GetTypeParameterList(typeSymbol))
            .AppendLine();

        sb.Append(indent).AppendLine("{");

        var fieldIndent = indent + "    ";

        sb.Append(fieldIndent)
            .Append("private static readonly global::Amethystra.Diagnostics.AppLog.Logger Log = ")
            .Append(GetLoggerFactoryExpression(typeSymbol, fullyQualifiedType))
            .AppendLine(";");

        sb.Append(indent).AppendLine("}");

        foreach (var line in CloseContainingTypes(typeSymbol))
        {
            sb.AppendLine(line);
        }

        return sb.ToString();
    }

    private static string GetLoggerFactoryExpression(INamedTypeSymbol typeSymbol, string fullyQualifiedType)
        => typeSymbol.IsStatic
            ? $"global::Amethystra.Diagnostics.AppLog.Default.For(typeof({fullyQualifiedType}))"
            : $"global::Amethystra.Diagnostics.AppLog.Default.For<{fullyQualifiedType}>()";

    private static IEnumerable<string> OpenContainingTypes(INamedTypeSymbol typeSymbol)
    {
        var stack = new Stack<INamedTypeSymbol>();
        for (var t = typeSymbol.ContainingType; t is not null; t = t.ContainingType)
        {
            stack.Push(t);
        }

        var indentLevel = 0;

        while (stack.Count > 0)
        {
            var t = stack.Pop();
            var indent = new string(' ', indentLevel * 4);

            var keyword = GetTypeKeyword(t);
            var typeParams = GetTypeParameterList(t);
            var staticModifier = GetStaticModifier(t);

            yield return $"{indent}partial {staticModifier}{keyword} {t.Name}{typeParams}";
            yield return $"{indent}{{";

            indentLevel++;
        }
    }

    private static IEnumerable<string> CloseContainingTypes(INamedTypeSymbol typeSymbol)
    {
        var levels = 0;
        for (var t = typeSymbol.ContainingType; t is not null; t = t.ContainingType)
        {
            levels++;
        }

        for (var i = levels - 1; i >= 0; i--)
        {
            var indent = new string(' ', i * 4);
            yield return $"{indent}}}";
        }
    }

    private static int GetIndentLevel(INamedTypeSymbol typeSymbol)
    {
        var levels = 0;
        for (var t = typeSymbol.ContainingType; t is not null; t = t.ContainingType)
        {
            levels++;
        }

        return levels;
    }

    private static string GetTypeKeyword(INamedTypeSymbol typeSymbol)
        => typeSymbol.TypeKind switch
        {
            TypeKind.Struct => "struct",
            _ => "class",
        };

    private static string GetStaticModifier(INamedTypeSymbol typeSymbol)
        => typeSymbol.IsStatic ? "static " : string.Empty;

    private static string GetTypeParameterList(INamedTypeSymbol typeSymbol)
    {
        if (typeSymbol.TypeParameters.Length == 0)
        {
            return string.Empty;
        }

        var names = string.Join(", ", typeSymbol.TypeParameters.Select(static x => x.Name));
        return $"<{names}>";
    }

    private readonly struct Target(INamedTypeSymbol typeSymbol, TypeDeclarationSyntax typeSyntax)
    {
        public INamedTypeSymbol TypeSymbol { get; } = typeSymbol;

        public TypeDeclarationSyntax TypeSyntax { get; } = typeSyntax;
    }
}
