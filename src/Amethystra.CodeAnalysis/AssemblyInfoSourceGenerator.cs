using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Text;

namespace Amethystra.CodeAnalysis;

[Generator(LanguageNames.CSharp)]
public sealed class AssemblyInfoSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var model = context.CompilationProvider
            .Select(static (compilation, _) => AssemblyData.Create(compilation))
            .Combine(context.AnalyzerConfigOptionsProvider.Select(static (provider, _) => GetRootNamespace(provider)));
        context.RegisterSourceOutput(
            model,
            static (spc, pair) =>
            {
                var data = pair.Left;
                var ns = pair.Right;
                var source = SourceEmitter.Emit(data, ns);
                spc.AddSource("ThisAssembly.g.cs", SourceText.From(source, Encoding.UTF8));
            });
    }

    private static string GetRootNamespace(AnalyzerConfigOptionsProvider provider)
        => provider.GlobalOptions.TryGetValue("build_property.RootNamespace", out var value)
            ? value.Trim()
            : "";

    private sealed class AssemblyData(
        string title,
        string description,
        string company,
        string product,
        string copyright,
        string trademark,
        Version version,
        string informationalVersion)
    {
        public string Title { get; } = title;

        public string Description { get; } = description;

        public string Company { get; } = company;

        public string Product { get; } = product;

        public string Copyright { get; } = copyright;

        public string Trademark { get; } = trademark;

        public Version Version { get; } = version;

        public string InformationalVersion { get; } = informationalVersion;

        public static AssemblyData Create(Compilation compilation)
        {
            var assembly = compilation.Assembly;
            var title = GetStringAttribute(assembly, "System.Reflection.AssemblyTitleAttribute", "Title");
            var description = GetStringAttribute(assembly, "System.Reflection.AssemblyDescriptionAttribute", "Description");
            var company = GetStringAttribute(assembly, "System.Reflection.AssemblyCompanyAttribute", "Company");
            var product = GetStringAttribute(assembly, "System.Reflection.AssemblyProductAttribute", "Product");
            var copyright = GetStringAttribute(assembly, "System.Reflection.AssemblyCopyrightAttribute", "Copyright");
            var trademark = GetStringAttribute(assembly, "System.Reflection.AssemblyTrademarkAttribute", "Trademark");
            var informationalVersion = GetStringAttribute(assembly, "System.Reflection.AssemblyInformationalVersionAttribute", "InformationalVersion");

            if (string.IsNullOrWhiteSpace(product)) product = assembly.Name;
            if (string.IsNullOrWhiteSpace(title)) title = product;

            var v = assembly.Identity.Version;
            var version = new Version(v.Major, v.Minor, v.Build, v.Revision);

            return new AssemblyData(
                title,
                description,
                company,
                product,
                copyright,
                trademark,
                version,
                informationalVersion);
        }

        private static string GetStringAttribute(IAssemblySymbol assembly, string attributeMetadataName, string namedArgumentKey)
        {
            foreach (var attr in assembly.GetAttributes()
                         .Where(attr => attr.AttributeClass?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::" + attributeMetadataName))
            {
                foreach (var kv in attr.NamedArguments
                             .Where(kv => string.Equals(kv.Key, namedArgumentKey, StringComparison.Ordinal)))
                {
                    if (kv.Value.Value is string s)
                    {
                        return s;
                    }
                }

                // ReSharper disable once MergeIntoPattern
                if (attr.ConstructorArguments.Length == 1 && attr.ConstructorArguments[0].Value is string s2)
                {
                    return s2;
                }

                return "";
            }

            return "";
        }
    }

    private static class SourceEmitter
    {
        public static string Emit(AssemblyData data, string rootNamespace)
        {
            var sb = new StringBuilder();

            sb.AppendLine("// <auto-generated/>");
            sb.Append("// This file was generated by ").Append(typeof(AssemblyInfoSourceGenerator).FullName).AppendLine(".");
            sb.AppendLine("// Do not edit this file manually.");
            sb.AppendLine();
            sb.AppendLine("using System;");
            sb.AppendLine();

            var hasRoot = string.IsNullOrWhiteSpace(rootNamespace) == false;
            var propertiesNamespace = hasRoot ? $"{rootNamespace}.Properties" : "Properties";

            if (hasRoot)
            {
                sb.AppendLine($"namespace {rootNamespace}");
                sb.AppendLine("{");
            }

            sb.AppendLine("    internal static class ThisAssembly");
            sb.AppendLine("    {");
            sb.AppendLine($"        public static global::Amethystra.Properties.IAssemblyInfo Info {{ get; }} = new global::{propertiesNamespace}.AssemblyInfo();");
            sb.AppendLine("    }");

            if (hasRoot)
            {
                sb.AppendLine("}");
            }

            sb.AppendLine();
            sb.AppendLine($"namespace {propertiesNamespace}");
            sb.AppendLine("{");
            sb.AppendLine("    internal sealed class AssemblyInfo : global::Amethystra.Properties.IAssemblyInfo");
            sb.AppendLine("    {");
            sb.AppendLine($"        private readonly string _informationalVersion = {ToLiteral(data.InformationalVersion)};");
            sb.AppendLine();
            sb.AppendLine($"        public string Title => {ToLiteral(data.Title)};");
            sb.AppendLine($"        public string Description => {ToLiteral(data.Description)};");
            sb.AppendLine($"        public string Company => {ToLiteral(data.Company)};");
            sb.AppendLine($"        public string Product => {ToLiteral(data.Product)};");
            sb.AppendLine($"        public string Copyright => {ToLiteral(data.Copyright)};");
            sb.AppendLine($"        public string Trademark => {ToLiteral(data.Trademark)};");
            sb.AppendLine();
            sb.AppendLine($"        public Version Version {{ get; }} = new Version({data.Version.Major}, {data.Version.Minor}, {data.Version.Build}, {data.Version.Revision});");
            sb.AppendLine("        public string VersionString => this.Version.ToString(3);");
            sb.AppendLine("        public string InformationalVersion => string.IsNullOrWhiteSpace(this._informationalVersion) ? this.VersionString : this._informationalVersion;");
            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        private static string ToLiteral(string value)
            => SymbolDisplay.FormatLiteral(value ?? "", true);
    }
}
